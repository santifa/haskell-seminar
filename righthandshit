expression kram

12.2)

data Expr
    = Var VarName | Con ConName[Expr] | Compose[Expr]
      deriving(Eq)

type VarName = Char
type ConName = String



fst     -> Con "fst" []
fst.f   -> Compose[Con "fst" [], Var 'f']
map f   -> Con "map" [Var 'f']
cross(f,g) -> Con "cross" [Var 'f', Var 'g']




foldr(f,e).nil  -> e
foldr(f,e).cons -> f.cross(id,foldr(f,e))


Compose[Var 'f', Var 'g', Var 'h']




compose :: [Expr] -> Expr
compose xs  = if singleton xs
              then head xs
              else Compose(concat(map decompose xs))

decompose :: Expr -> [Expr]
decompose(Var v)        = [Var v]
decompose(Con f xs)     = [Con f xs]
decompose(Compose xs)   = xs




complexity :: Expr -> Int
complexity (Var v)      = 1
complexity (Con f xs)   = 1
complexity (Compose xs) = length xs





printExpr :: Expr -> String
printExpr (Var v)   = [v]

printExpr (Con f xs) 
    | null xs       = f
    | simple xs     = f ++ "u" ++  printExpr(head xs)
    | otherwise     = f ++ "(" ++
                        joinWith ",u" (map printExpr xs) ++ ")"

printExpr (Compose xs) = joinWith "." (map printExpr xs)



simple :: [Expr] -> Bool
simple xs = singleton xs && simpleton(head xs)

simpleton :: Expr -> Bool
simpleton (Var v)   = True
simpleton (Con f xs) = null xs
simpleton (Compose xs) = False




parseExpr :: String -> Expr
parseExpr = applyParser expr


expr :: Parser Expr
expr = do { xs <- somewith (symbol ".") term; return (compose xs)}


term :: Parser Expr
term = do space
         c <- letter
         cs <- many alphanum
         if null cs
            then return (Var c)
            else   do xs <- argument
                      return (Con (c:cs) xs)



argument :: Parser [Expr]
argument = tuple orelse (notuple orelse return [])


tuple :: Parser [Expr]
tuple = do symbol "("
           xs <- somewith (symbol ",") expr
           symbol ")"
           return xs




notuple :: Parser Expr
notuple = do space
             c <- letter
             cs <- many alphanum
             if null cs
                then return [Var c]
                else return [Con(c:cs)[]]



parseEqn :: String -> (Expr, Expr)
parseEqn = applyParser eqn

eqn :: Parser (Expr, Expr)
eqn = do space
         x <- expr
         symbol "="
         y <- expr
         return(x,y)
