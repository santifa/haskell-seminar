seite 387

< laws = filters ++ ifs ++others
< 
< filters
<   = map parseLaw [
<     "definition filter: filter p = concat.map(box p)",
<     "definition box:    box p = if(p, wrap, nil)"
<   ]
< 
< ifs
<   = map parseLaw [
<     "if over composiition:  if(p,f,g).h = if(p.h, f.h, g.h)",
<     "composition over if:   h.if(p,f,g) = if(p, h.f, h.g)"
<   ]
< 
< others
<   = map ParseLaw [
<     "nil constant:      nil.f = nil",
<     "nil natural:       map f.nil = nil",
<     "wrap natural:      map f.wrap = wrap.f",
<     "concat natural:    map f.concat = concat.map(map f)",
<     "map functor:       map f.map g = map(f.g)"
<   ]
< 
< 
< ? prove laws "filter p.map f = map f.filter(p.f)"
< 
<   filter p.map f
< =   {definition filter}
<   concat.map(box p).map f
< =   {map functor}
<   concat.map(box p.f)
< =   {definition box}
<   concat.map(if(p, wrap.f, nil).f)
< =   {if over composition}
<   concat.map(if(p, wrap.f, nil.f))
< =   {nil constant}
<   concat.map(if(p.f, wrap.f, nil))
< =   {wrap natural}
<   concat.map(if(p.f, map f.wrap, nil))
< =   {nil natural}
<   concat.map(if(p.f, map f.wrap, map f.nil))
< =   {composition over if}
<   concat.map(map f.if(p.f, wrap, nil))
< =   {definition box}
<   concat.map(map f.box(p.f))
< =   {map functor}
<   concat.map(map f).map(box(p.f))
< =   {concat natural}
<   map f.concat.map(box(p.f))
< =   {definition filter}
<   map f.filter(p.f)









expression kram

12.2)

> data Expr
>     = Var VarName | Con ConName[Expr] | Compose[Expr]
>       deriving(Eq)
> 
> type VarName = Char
> type ConName = String



fst     -> Con "fst" []
fst.f   -> Compose[Con "fst" [], Var 'f']
map f   -> Con "map" [Var 'f']
cross(f,g) -> Con "cross" [Var 'f', Var 'g']




foldr(f,e).nil  -> e
foldr(f,e).cons -> f.cross(id,foldr(f,e))


Compose[Var 'f', Var 'g', Var 'h']




compose :: [Expr] -> Expr
compose xs  = if singleton xs
              then head xs
              else Compose(concat(map decompose xs))

decompose :: Expr -> [Expr]
decompose(Var v)        = [Var v]
decompose(Con f xs)     = [Con f xs]
decompose(Compose xs)   = xs




complexity :: Expr -> Int
complexity (Var v)      = 1
complexity (Con f xs)   = 1
complexity (Compose xs) = length xs





printExpr :: Expr -> String
printExpr (Var v)   = [v]

printExpr (Con f xs) 
    | null xs       = f
    | simple xs     = f # ""

